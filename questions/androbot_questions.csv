Category;Question;Answer;Info
General;Перечислите четыре основных ĸомпонента Android приложения;activity, service, broadcast receiver, content provider;https://developer.android.com/guide/components/fundamentals?hl=ru
Activity;Из каких этапов(коллбэков) состоит жизненный циĸл аĸтивити?;onCreate -> onStart -> onResume -> (Activity running) -> onPause -> onStop -> onDestroy;https://developer.android.com/guide/components/activities/activity-lifecycle
Activity;Каĸие методы жизненного циĸла будут вызваны после старта другого активити?;onPause -> onStop;https://developer.android.com/guide/components/activities/activity-lifecycle
Activity;Дайте определение, что таĸое affinity и finishAffinity?;"affinity это связь активити со своим task(задачей)
finishAffinity - завершит все активити в этом task(задаче)
";https://developer.android.com/guide/topics/manifest/activity-element#aff
Activity;Что таĸое Window?;Класс, который отвечает за отрисовку стандартных компонентов системы на экране(статус бар, системные кнопки и т.д.);https://developer.android.com/reference/android/view/Window
Activity;Какие флаги запуска активити есть(launchMode)?;"standart. Установлен по умолчанию. Запускает новый инстанс активити в той же задаче(task), с таким флагом активити может иметь любое количество экземпляров себя в свой же задаче и в других
singleTop. Если активити уже есть на верхушке(top) задачи(task), то новое активити создаваться не будет, а будет редирект на уже имеющееся активити, но если это активити не на верху задачи, то будет создан еще один экземпляр активити
singleTask. Активити запущенное с таким флагом будет запущено в новой задаче, но если такое активити уже есть в другой задачи, то будет редирект на это активити
singleInstance. В каждой задаче может быть только один экземпляр этого активити. Все активити, которые запускаются из этого активити, будут запускаться в отдельной задаче.
";https://developer.android.com/guide/components/activities/tasks-and-back-stack#TaskLaunchModes 
General;Из каких этапов(коллбэков) состоит жизненный циĸл Fragment;onAttach -> onCreate -> onCreateView -> onActivityCreated -> onStart -> onResume -> (Fragment running) -> onPause -> onStop -> onDestroyView -> onDetach;https://developer.android.com/guide/fragments
General;Из каких этапов(коллбэков) состоит жизненный циĸл Service и IntentService?;"Service: onCreate -> onBind -> (Service running) -> onUnbind -> onDestroy
IntentService: onCreate -> onStartCommand -> (Do task) -> onDestroy";https://developer.android.com/guide/components/services?hl=ru
View;Из каких этапов состоит жизненный циĸл View;"Constructor -> onAttachToWindow -> onMeasure -> onLayout -> onDraw -> UI shown
";https://medium.com/@sahoosunilkumar/understanding-view-lifecycle-in-android-e42890aab16
View;В чем разница между view и viewgroup?;"View это единичный элемент отображения, а ViewGroup это своего рода контейнер под другие View или ViewGroup
";https://developer.android.com/reference/android/view/View
Java;"Что означает ĸлючевое слово static?
";Если мы помечаем этим ключевым словом класс/переменную/метод, то мы можем получить доступ к ним без создания объекта этого класса;https://javadevblog.com/chto-takoe-static-v-java-staticheskie-metody-peremenny-e-staticheskij-blok-i-java-klass.html
Java;В чем особенность блоĸа finally? Всегда ли он исполняется?;Блок finally выполняется в конструкции try-catch-finally и он будет выполняться всегда, даже когда исключение не было брошено. Это хорошее место в коде, чтобы высвобождать ресурсы.;https://www.frolov-lib.ru/programming/javasamples/vol1/vol1_9/index.html
Kotlin;Что такое Unit? (дайте определение);Unit это реализации функций которые ничего не возвращают. То есть в Java такие функции помечаются ключевым словом void. А в Kotlin таким функциям устанавливается тип возвращаемого значения Unit(по умолчанию, если у функции не указан тип возвращаемого значения, то он Unit);
General;Что такое TDD? (дайте определение);TDD это Test Driven Development, парадигма разработки при которой, сначала пишутся тесты, которые должные быть успешно пройдены, а потом уже сам исполняемый код.;
Architecture;Считаете ли вы Singleton антипаттерном? Почему?;"Singleton(Синглтон) является наверное самым популярным паттерном в программировании, если вы подойдете к любому мало-мальски изучающему программирование человеку и спросит у него какие паттерны он знает Синглтон будет в топ-два…

Так почему же он антипаттерн? Вообще, это условно “холиварная тема”, кто-то говорит, что его просто не там и не так используют, кто-то говорит, что от него одни проблемы, а правда, скорее всего где-то посередине, так как - да, его зачастую используют там где не надо и второе тоже верно у него есть свои недостатки.

Давайте разберем очевидные недостатки этого паттерна.

1) *ПотокоНЕбезопасность*. Как правило Синглтон реализуется через ленивую инициализацию, то есть его инстанс будет создан только при обращении, вызвав соответствующий метод. И если это сделают сразу два потока одновременно, то потенциально могут быть созданы сразу два инстанса.

Эту проблему можно, конечно решить при помощи ключевого слова synchronized или сделать двойную проверку. Но, по большому счету, и то и другое не эффективно.

2) *Сериализация*. Синглтон запрещает нам создание через конструктор, но не запрещает нам создание объектов в принципе. Поэтому мы можем обойти этот запрет воспользовавшись сериализацией/десериализацией

3) *Тестирование*. Синглтон затрудняет тестирование, так как такой класс нельзя подменить и придется в тестах тестировать и его, а отсюда вытекает, что порядок тестов теперь важен, нельзя запускать несколько тестов одновременно и разные прочие сайд эффекты

4) *Рефлексия*. Так как в синглтоне мы делаем конструктор приватным, что не позволяет нам создавать новые инстансы через него. То рефлексия легко обходит данные ограничения

5) *Принцип единственной ответственности*. Исходя из принципов SOLID, а именно из буквы S (Single Responsibility Principle), каждый класс должен отвечать только за что-то одно. А в нашем случае у нас класс отвечает как минимум за две вещи, первая - он не допускает создании второго своего инстанса и вторая - уже какая-то логика которую он делает. Учитывает все это, данный подход может навредить дальнейшей гибкости и масштабируемости класса. Также этот класс мы не можем переиспользовать

Учитывая все это и то, что технологии сейчас позволяют реализовывать идею синглтона гораздо проще и без таких побочных эффектов. Скорее всего синглтон, в его каноническом виде, скорее всего не стоит.";"Что такое синглтон: https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
Статья про синглтон: https://habr.com/ru/post/129494/"
Architecture;Объясните принципы SOLID;"Если перевести слово SOLID на русский, то получиться что-то вроде “надежный” или “крепкий”, в конце-концов слово “солидный” тоже подойдет. Но, понятное дело, что это акроним, в котором каждая буква обозначает принципы построения программ, чтобы они были надежными легко поддерживаемыми и масштабируемыми. Если, хотите, чтобы ваш код был “солидный”, следуйте этим принципам:

- *S*ingle responsibility principle. Класс должен отвечать за что-то одно, то есть за какую-то одну задачу. Это не означает что нужно делать по классу на каждый метода, нет, это явно будет перегиб, но нужно стремиться чтобы один класс(или подсистема классов) глобально выполняли одну функцию. Так как если у одного класса есть две функции и в одной мы что-то меняем, то велика вероятность, что это затронет и другую функцию, что влечет за собой не гибкую масштабируемость и поддерживаемость.
- *O*pen-close principle. Принцип открытости/закрытости, классы должны быть открыты для расширения и закрыты для изменения. Ну тут все просто, классы должны проектироваться таким образом, чтобы мы могли их расширять, то есть добавлять новый код, а не менять, то есть изменять уже существующий код.
- *L*iskov substitutions principle. Принцип подстановки Барбары Лисков, этот принцип гласит, что мы должны писать код так, чтобы классы-наследники могли заменить классы-родители и программа от этого не должна сломаться.
- *I*nterface segregation principle. Принцип разделения интерфейсов. В общем если сказать по простому то нужно использовать узкоспециализированные интерфейсы, не нужно переиспользовать интерфейсы если он не реализуется на 100%. Как иногда делается, применяется интерфейс, которые реализует один метод, а остальные методы остаются пустыми. Так делать не стоит.
- *D*ependency injection principle. Принцип инверсии зависимостей. Зависимости должны предоставляться через абстракции. То есть если у вас в классе есть конструктор, куда передается другой класс, то, в идеале, нужно передать туда абстракцию (интерфейс или абстрактный класс), но не конкретную реализацию";"Отличная статья на русском: https://medium.com/webbdev/solid-4ffc018077da
И еще одна: https://habr.com/ru/post/348286/"
Architecture;Объясните принципы Clean Architecture;"Clean Architecture предлагает нам делить приложение на слои, приложение как самостоятельную единицу, например мобильное приложение, а также можно рассматривать сервис и целиком, то есть у нас есть интернет магазин у которого есть и мобильное приложение и web сайт и еще что-нибудь . Выделяются четыре слоя приложения: Entity, Use cases, Interface Adapters(Controllers, Presenters и т.д), Frameworks и Drivers

https://miro.medium.com/max/772/0\*sfCDEb571WD-7EfP.jpg

- Entities - здесь находятся сущности которые будут использоваться во всех слоях, это верхний уровень абстракции, все остальные слои будут зависеть от этого слоя.
- Use Cases - здесь находятся контракты взаимодействия между сущностями из Entities, различные интерфейсы и тому подобное
- Controllers, Presenters - в этом слое находятся различные компоненты, через которые будут общаться между собой внешние слои фреймворков, например тут будут располагаться MV\* подходы.
- Frameworks и Drivers, в это слое у на находятся уже конкретные библиотеки и фреймворки

Также все зависимости направлены внутрь, то есть каждый слой зависит от внутреннего слоя и не зависит от внешнего.";"Статья: https://habr.com/ru/post/464185/
Статья на английском от автора Clean Architecture: https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"
Activity;Разница между Explicit/impicit intent;"- Explicit intent - явный интент, когда мы запускаем какой-либо компонент (activity, service и т.д.) указываю при этом или package name или по имени класса. Как правило такой способ используется для запуска компонентов в пределах одного приложения, потому как только здесь мы можем знать имя класса(по package name можно запустить и из другого приложения)
- Implicit intent - неявный интент, это запуск приложения по action, который представляет из себя строку. Есть как системные action, которые выведены в константы и могут запустить какой-либо сервис или наоборот мы хотим получить сообщение от системы по какому либо action(например низкий заряд батареи). Но также можно создать и свой кастомный action, по которому, зная его, можно будет что-то запустить из другого приложения.";"Официфальная документация: https://developer.android.com/guide/components/intents-filters#Types 
"
Activity;Разница между Context?;"Есть контекст активити, а есть контекст всего приложения, если говорить оригинальными терминами то есть application context и activity context и тот и другой является синглтоном и тот и другой предоставляют доступ к ресурсам и взаимодействию с системой, но есть и отличие.

- application context - этот контекст, доступен, по приложение “живет”, поэтому этот контекст лучше предоставлять тем компонентам, жизненный цикл которых равен жизненному циклу приложения
- activity context - этот контекст, доступен, пока живо то активити у которого вы его взяли, такой контекст плохо передавать в объекты, ЖЦ которых не равны жизненному циклу этого активити, так как если ссылка на этот контекст будет жить в другом объекте, ваше активити не будет уничтожено, после того как вы из него уйдете, что приведет к утечка памяти

Не стоит использовать application context для старта активити, так как будет использована дефолтная тема.

Также контекст есть у других android компонентов, вот табличка какой контекст что может представлять:

https://lh4.googleusercontent.com/9Fh7pwb-iNw_uKEcpSdjWrxTGVn9J-mFLozm5pQa8B30KcrEASWFautsQBv5vdDBZwcAwBa5_i32QvSufBzCfsAb-6JO1u52FmGzhOrnhSD6g6WYhXBS73YBRiE7oe6q_zSaMbQj";Статья: https://habr.com/ru/post/421115/